<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
  <title>WebAR — Image Scan → Spawn GLB (Auto-fit)</title>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
      "mindar-image-three": "https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-three.prod.js"
    }
  }
  </script>

  <style>
    html,body{margin:0;height:100%;background:#000;overflow:hidden;font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
    #container{position:fixed;inset:0}
    #container video{position:fixed;inset:0;width:100%;height:100%;object-fit:cover;z-index:0}
    #container canvas{position:fixed;inset:0;z-index:1}
    #hint{position:fixed;left:0;right:0;top:10px;text-align:center;color:#fff;opacity:.9;z-index:3}
    #ui{position:fixed;left:12px;right:12px;bottom:12px;z-index:4;display:flex;gap:8px;justify-content:center;flex-wrap:wrap}
    button,a.button{padding:10px 14px;border:0;border-radius:12px;font-size:16px;font-weight:600;cursor:pointer;background:#4f46e5;color:#fff;text-decoration:none}
    button.secondary{background:#374151}
  </style>
</head>
<body>
  <div id="hint">Point your camera at the target image</div>
  <div id="container"></div>

  <div id="ui">
    <button id="startBtn">Start AR</button>
    <button id="restartBtn" class="secondary">Restart</button>
    <a id="ctaBtn" class="button" href="#" target="_blank" rel="noopener">Visit Site</a>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { MindARThree } from 'mindar-image-three';
    import { GLTFLoader }  from 'three/addons/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

    // ========= CONFIG (edit these) =========
    const CTA_URL = 'https://example.com';
    const MODEL_URL = './model.glb';  // your file next to index.html

    // MindAR uses meters-ish units. By default, the image width ≈ 1.0 unit.
    // So 0.8 means 80% of the image width.
    const FIT_MODE = 'width';         // 'width' | 'height' | 'max'
    const MODEL_SIZE_M = 0.8;         // target size in meters along FIT_MODE axis
    const MODEL_LIFT_M = 0.02;        // raise model above image (meters)
    const MODEL_ROT_X = 0;            // rotate if it's lying the wrong way
    const MODEL_ROT_Y = 0;
    const MODEL_ROT_Z = 0;

    const LOCK_ANCHOR_SCALE = false;  // true = copy anchor scale; false = use 1,1,1
    const SHOW_AXES_DEBUG = false;    // true shows axis gizmos to judge orientation
    // ======================================

    // UI
    document.getElementById('ctaBtn').href = CTA_URL;
    const container  = document.getElementById('container');
    const startBtn   = document.getElementById('startBtn');
    const restartBtn = document.getElementById('restartBtn');
    const hint       = document.getElementById('hint');

    // MindAR
    const mindar = new MindARThree({
      container,
      imageTargetSrc: './targets.mind',
      uiLoading:'no', uiScanning:'no', uiError:'no',
      warmupTolerance: 2, missTolerance: 8
    });
    const { renderer, scene, camera } = mindar;
    renderer.setClearColor(0x000000, 0);
    renderer.domElement.style.touchAction = 'none';

    // Lighting (needed for PBR)
    scene.add(new THREE.AmbientLight(0xffffff, 0.9));
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(1, 2, 1);
    scene.add(dir);

    // Anchor (we only read its pose once)
    const anchor = mindar.addAnchor(0);

    // World-space pivot where the model will live permanently
    const worldRoot = new THREE.Group();
    scene.add(worldRoot);

    if (SHOW_AXES_DEBUG) {
      scene.add(new THREE.AxesHelper(0.2));     // scene axes
      worldRoot.add(new THREE.AxesHelper(0.2)); // model parent axes
    }

    // GLB loader (with Draco support; harmless if not compressed)
    const gltfLoader = new GLTFLoader();
    const draco = new DRACOLoader();
    draco.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
    draco.setDecoderConfig({ type: 'js' });
    gltfLoader.setDRACOLoader(draco);

    let modelPrefab = null;
    let spawned = false;

    function loadModel(){
      return new Promise((resolve, reject) => {
        gltfLoader.load(
          MODEL_URL,
          (gltf) => { modelPrefab = gltf.scene; resolve(); },
          undefined,
          (err) => { console.error('Model load error', err); hint.textContent='Failed to load model'; reject(err); }
        );
      });
    }

    // --- Helpers: center & fit model by bounds ---
    function centerByBounds(object){
      // Move the model so its bounding-box center sits at the group's origin
      const box = new THREE.Box3().setFromObject(object);
      const center = box.getCenter(new THREE.Vector3());
      object.position.sub(center); // recenters pivot
      object.updateMatrixWorld(true);
    }

    function fitByBounds(object, fitMode = 'width', desired = 1.0){
      const box = new THREE.Box3().setFromObject(object);
      const size = box.getSize(new THREE.Vector3());
      let current = size.x;
      if (fitMode === 'height') current = size.y;
      if (fitMode === 'max')    current = Math.max(size.x, size.y, size.z);
      const scale = (current > 0.00001) ? (desired / current) : 1;
      object.scale.multiplyScalar(scale);
      object.updateMatrixWorld(true);
    }

    // Copy position/rotation (and optionally scale) from the anchor to worldRoot
    const _p = new THREE.Vector3(), _q = new THREE.Quaternion(), _s = new THREE.Vector3();
    function lockWorldTransformFromAnchor(anchorGroup, targetGroup){
      anchorGroup.updateWorldMatrix(true, true);
      anchorGroup.getWorldPosition(_p);
      anchorGroup.getWorldQuaternion(_q);
      anchorGroup.getWorldScale(_s);
      targetGroup.position.copy(_p);
      targetGroup.quaternion.copy(_q);
      targetGroup.scale.copy(LOCK_ANCHOR_SCALE ? _s : new THREE.Vector3(1,1,1));
      targetGroup.updateMatrixWorld(true);
    }

    // First detection → place once and keep
    anchor.onTargetFound = async () => {
      hint.textContent = 'Tracking ✓';
      if (spawned) return;

      if (!modelPrefab) { try { await loadModel(); } catch { return; } }

      // freeze the pose where the target is now
      lockWorldTransformFromAnchor(anchor.group, worldRoot);

      // clone, then center → fit → rotate → lift → add
      const instance = modelPrefab.clone(true);

      // 1) center pivot to the model's bounds center
      centerByBounds(instance);

      // 2) scale to fit target size (e.g., % of image width)
      fitByBounds(instance, FIT_MODE, MODEL_SIZE_M);

      // 3) apply any rotation fixes (if it lies flat/backwards)
      instance.rotation.set(MODEL_ROT_X, MODEL_ROT_Y, MODEL_ROT_Z);

      // 4) offset above the image so it doesn't intersect
      instance.position.y += MODEL_LIFT_M;

      if (SHOW_AXES_DEBUG) instance.add(new THREE.AxesHelper(0.2));
      worldRoot.add(instance);

      spawned = true;
      hint.textContent = 'Placed ✓ You can move away.';
    };

    anchor.onTargetLost = () => {
      hint.textContent = spawned ? 'Model placed — move around freely' : 'Move back to the target…';
    };

    // Buttons
    restartBtn.addEventListener('click', async () => {
      try { await mindar.stop(); } catch {}
      renderer.setAnimationLoop(null);

      // reset placement so you can re-place on next detection
      worldRoot.clear();
      spawned = false;

      await mindar.start();
      renderer.setAnimationLoop(() => renderer.render(scene, camera));
      hint.textContent = 'Point your camera at the target image';
    });

    startBtn.addEventListener('click', async () => {
      startBtn.disabled = true; startBtn.textContent = 'Starting…';
      try {
        await mindar.start();
        renderer.setAnimationLoop(() => renderer.render(scene, camera));
        startBtn.textContent = 'Running…';
      } catch (e) {
        console.error(e);
        startBtn.disabled = false; startBtn.textContent = 'Start AR (Retry)';
      }
    });

    // Keep renderer sized to container
    new ResizeObserver(() => {
      renderer.setSize(container.clientWidth, container.clientHeight, false);
    }).observe(container);
  </script>
</body>
</html>
